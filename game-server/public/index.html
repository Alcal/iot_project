<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Serverboy Viewer</title>
    <style>
      body { margin: 0; background: #111; color: #eee; font-family: system-ui, sans-serif; }
      .wrap { display: flex; gap: 16px; padding: 16px; align-items: flex-start; }
      canvas { image-rendering: pixelated; image-rendering: crisp-edges; background: #000; }
      .controls { display: grid; gap: 8px; }
      button { padding: 8px 12px; background: #333; color: #eee; border: 1px solid #444; border-radius: 6px; cursor: pointer; }
      button:active { transform: translateY(1px); }
      .grid { display: grid; grid-template-columns: repeat(3, 48px); gap: 6px; }
    </style>
  </head>
  <body>
    <div class="wrap">
      <canvas id="screen" width="160" height="144"></canvas>
      <div class="controls">
        <div>
          <div class="grid">
            <button data-k="UP">UP</button>
            <button data-k="A">A</button>
            <button data-k="B">B</button>
            <button data-k="LEFT">LEFT</button>
            <button data-k="DOWN">DOWN</button>
            <button data-k="RIGHT">RIGHT</button>
          </div>
        </div>
        <div>
          <button id="start">START</button>
          <button id="select">SELECT</button>
          <button id="restart">RESTART</button>
        </div>
      </div>
    </div>
    <button id="enable-audio" style="position:fixed;top:8px;right:8px;">Enable Audio</button>
    <script src="https://cdn.socket.io/4.8.1/socket.io.min.js" integrity="sha384-mkQ3/7FUtcGyoppY6bz/PORYoGqOl7/aSUMn2ymDOJcapfS6PHqxhRTMh1RR0Q6+" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js" integrity="sha512-g2TeAWw5GPnX7z0Kn8nFbYfeHcvAu/tx6d6mrLe/90mkCxO+RcptyYpksUz35EO337F83bZwcmUyHiHamspkfg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="video-decode.js"></script>
    <script>
      const socket = io();
      const canvas = document.getElementById('screen');
      const ctx = canvas.getContext('2d');
      const imageData = ctx.createImageData(160, 144);
      
      // No keyframe requests necessary; server always sends keyframes

      socket.on('frame', (packet) => {
        try {
          const decoded = VideoCodec.decodeFrame(packet);
          // Copy into ImageData
          imageData.data.set(decoded);
        } catch (err) {
          console.warn('[serverboy][video] decode error:', err);
          return;
        }
        ctx.putImageData(imageData, 0, 0);
      });

      function sendKey(ev, down) {
        const k = ev.target.getAttribute('data-k');
        if (!k) return;
        socket.emit(down ? 'keydown' : 'keyup', { key: k });
      }

      document.querySelectorAll('button[data-k]').forEach((btn) => {
        btn.addEventListener('mousedown', (e) => sendKey(e, true));
        btn.addEventListener('mouseup', (e) => sendKey(e, false));
        btn.addEventListener('mouseleave', (e) => sendKey(e, false));
        btn.addEventListener('touchstart', (e) => { e.preventDefault(); sendKey({ target: btn }, true); });
        btn.addEventListener('touchend', (e) => { e.preventDefault(); sendKey({ target: btn }, false); });
      });

      document.getElementById('start').addEventListener('click', () => socket.emit('keydown', { key: 'START' }));
      document.getElementById('select').addEventListener('click', () => socket.emit('keydown', { key: 'SELECT' }));
      document.getElementById('restart').addEventListener('click', () => socket.emit('restart'));

      const keymap = { ArrowUp: 'UP', ArrowDown: 'DOWN', ArrowLeft: 'LEFT', ArrowRight: 'RIGHT', KeyZ: 'A', KeyX: 'B', Enter: 'START', ShiftLeft: 'SELECT' };
      window.addEventListener('keydown', (e) => { const k = keymap[e.code]; if (k) { e.preventDefault(); socket.emit('keydown', { key: k }); } });
      window.addEventListener('keyup', (e) => { const k = keymap[e.code]; if (k) { e.preventDefault(); socket.emit('keyup', { key: k }); } });

      // ---- Audio (WebAudio with AudioWorklet fallback) ----
      let audioCtx = null;
      let workletNode = null;
      let procNode = null; // fallback
      const audioQueue = []; // fallback buffer
      const TARGET_SR = 44100;

      function toU8(input) {
        if (input == null) return null;
        if (input instanceof Uint8Array) return input;
        if (input instanceof ArrayBuffer) return new Uint8Array(input);
        if (ArrayBuffer.isView(input)) return new Uint8Array(input.buffer, input.byteOffset, input.byteLength);
        return null;
      }

      function decodeCompressedAudio(packet) {
        try {
          const buf = toU8(packet);
          if (!buf || buf.length < 6) return null;
          // Header: 'A'(0) version(1) fmt(2) ch(3) srLE(4..5)
          if (buf[0] !== 0x41 || buf[1] !== 0x01) return null; // not our format
          const fmt = buf[2];
          const channels = buf[3];
          const sampleRate = buf[4] | (buf[5] << 8);
          if (fmt !== 0 || channels !== 1) return null; // only int16 mono supported
          if (!window.pako || !window.pako.inflate) return null;
          const body = buf.subarray(6);
          const inflated = window.pako.inflate(body);
          // Expect int16 PCM
          if ((inflated.byteLength & 1) !== 0) return null;
          const pcm16 = new Int16Array(inflated.buffer, inflated.byteOffset, inflated.byteLength >> 1);
          const out = new Float32Array(pcm16.length);
          for (let i = 0; i < pcm16.length; i++) out[i] = pcm16[i] / 32768;
          // return both data and the src sample rate for resampling
          return { data: out, sampleRate };
        } catch (err) {
          console.warn('[serverboy][audio] decodeCompressedAudio error:', err);
          return null;
        }
      }

      function resampleLinear(input, fromSR, toSR) {
        try {
          if (!input || input.length === 0 || !isFinite(fromSR) || !isFinite(toSR) || fromSR <= 0 || toSR <= 0) return new Float32Array(0);
          if (fromSR === toSR) return input;
          const ratio = toSR / fromSR;
          const outLen = Math.max(1, Math.round(input.length * ratio));
          const out = new Float32Array(outLen);
          const step = (input.length - 1) / (outLen - 1);
          for (let i = 0; i < outLen; i++) {
            const pos = i * step;
            const i0 = Math.floor(pos);
            const i1 = Math.min(input.length - 1, i0 + 1);
            const t = pos - i0;
            out[i] = input[i0] * (1 - t) + input[i1] * t;
          }
          return out;
        } catch (_) {
          return input;
        }
      }

      async function ensureAudio() {
        if (audioCtx) return;
        audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: TARGET_SR });
        try {
          await audioCtx.audioWorklet.addModule('audio-worklet.js');
          workletNode = new AudioWorkletNode(
            audioCtx,
            'queue-player',
            {
              numberOfOutputs: 1,
              outputChannelCount: [1],
              channelCount: 1,
              channelCountMode: 'explicit',
              channelInterpretation: 'speakers',
            }
          );
          workletNode.connect(audioCtx.destination);
        } catch (_) {
          console.warn('[serverboy][audio] AudioWorklet is unavailable, falling back to ScriptProcessor');
          // Fallback to ScriptProcessor if AudioWorklet is unavailable
          procNode = audioCtx.createScriptProcessor(2048, 0, 1);
          procNode.onaudioprocess = (e) => {
            const out = e.outputBuffer.getChannelData(0);
            let i = 0;
            while (i < out.length) {
              if (audioQueue.length === 0) { out.fill(0, i); break; }
              const chunk = audioQueue[0];
              const avail = Math.min(out.length - i, chunk.length);
              out.set(chunk.subarray(0, avail), i);
              i += avail;
              if (avail === chunk.length) audioQueue.shift();
              else audioQueue[0] = chunk.subarray(avail);
            }
          };
          procNode.connect(audioCtx.destination);
        }
      }

      document.getElementById('enable-audio').addEventListener('click', async () => {
        ensureAudio();
        try { await audioCtx.resume(); } catch (_) {}
        document.getElementById('enable-audio').style.display = 'none';
      });

      function normalizeToFloat32(samples) {
        try {
          // If we get a TypedArray view
          if (ArrayBuffer.isView(samples)) {
            if (samples instanceof Float32Array) return samples;
            if (samples instanceof Int16Array) {
              const out = new Float32Array(samples.length);
              for (let i = 0; i < samples.length; i++) out[i] = samples[i] / 32768;
              return out;
            }
            if (samples instanceof Uint8Array) {
              const out = new Float32Array(samples.length);
              for (let i = 0; i < samples.length; i++) out[i] = (samples[i] - 128) / 128;
              return out;
            }
            // Generic numeric view
            return Float32Array.from(samples, (x) => {
              const v = Number(x);
              if (!isFinite(v)) return 0;
              // Heuristic: values outside [-2,2] likely integer PCM; scale if int16 range
              const av = Math.abs(v);
              if (av > 2 && av <= 32768) return v / 32768;
              if (av > 2 && av <= 255) return (v - 128) / 128;
              return Math.max(-1, Math.min(1, v));
            });
          }

          // If we get raw ArrayBuffer (socket.io/binary)
          if (samples instanceof ArrayBuffer) {
            // Assume int16 PCM by default
            const int16 = new Int16Array(samples);
            const out = new Float32Array(int16.length);
            for (let i = 0; i < int16.length; i++) out[i] = int16[i] / 32768;
            return out;
          }

          // If we get plain number[]
          if (Array.isArray(samples)) {
            // Heuristic scaling as above
            return Float32Array.from(samples, (x) => {
              const v = Number(x);
              if (!isFinite(v)) return 0;
              const av = Math.abs(v);
              if (av > 2 && av <= 32768) return v / 32768;
              if (av > 2 && av <= 255) return (v - 128) / 128;
              return Math.max(-1, Math.min(1, v));
            });
          }
        } catch (err) {
          console.warn('[serverboy][audio] Failed to normalize audio samples:', err);
        }
        return new Float32Array(0);
      }

      socket.on('audio', (samples) => {
        // Ensure audio graph exists so we don't drop early chunks
        if (!audioCtx) ensureAudio();

        const decoded = decodeCompressedAudio(samples);
        let f32 = null;
        if (decoded && decoded.data) {
          const targetSR = audioCtx ? audioCtx.sampleRate : TARGET_SR;
          f32 = resampleLinear(decoded.data, decoded.sampleRate, targetSR);
        } else {
          f32 = normalizeToFloat32(samples);
        }
        if (f32.length === 0) return;

        if (workletNode && workletNode.port) {
          try {
            workletNode.port.postMessage({ buffer: f32.buffer }, [f32.buffer]);
          } catch (err) {
            console.warn('[serverboy][audio] Error posting message to AudioWorklet:', err);
          }
        } else {
          audioQueue.push(f32);
        }
      });
    </script>
  </body>
  </html>


